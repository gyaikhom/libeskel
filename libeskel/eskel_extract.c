/*********************************************************************

  THE ENHANCE PROJECT
  School of Informatics,
  University of Edinburgh,
  Edinburgh - EH9 3JZ
  United Kingdom

  Written by: Gagarine Yaikhom

*********************************************************************/

/**
   DESCRIPTION:

   This is part of the eSkel skeleton library. The program is used to
   extract execution and scheduling information from the output
   generated by the eSkel library. */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/types.h>
#include <unistd.h>

/* These macros expands to the member (or member pointer) in the ith
   row, jth column of the vector representation of two dimensional of
   matrix, m, where k is the number of columns in a row. */
#define __ESKEL_2DMBER(m, i, j, k) (*(m + (k * i) + j))
#define __ESKEL_2DMBER_PTR(m, i, j, k) (m + (k * i) + j)

static FILE *__eskel_summary_file = NULL;

typedef enum {
    UNKNOWN = 0,  /* Interface with outside. */
    PIPE,         /* Pipeline (sequential). */
    DEAL,         /* Round-robin distribution. */
    TASK,         /* Task function (leaf-node) */
    NSKEL         /* Number of patterns supported. */
} __eskel_comp_t; /* Hierarchy tree component. */

typedef struct __eskel_rmon_s __eskel_rmon_t;
struct __eskel_rmon_s {
    pid_t pid;             /* Process ID. */
    float cpufreq;         /* CPU clock speed. */
    int cpucount[2];       /* Number of cpus: configured and online. */
    float load[3];         /* The 1, 5, 15 minute load average. */
    float total, contrib;  /* Total CPU util., and my contrib.. */
    float theor;           /* Theoretical value based on nice values. */
    unsigned short nprocs; /* Total number of processes. */
    unsigned short rprocs; /* Total number of running processes. */
    double duration;       /* Duration of the current task. */
};

/* These are the sections under which the information are maintained. */
#define __ESKEL_SUMM_ENV 0
#define __ESKEL_SUMM_SKE 1
#define __ESKEL_SUMM_EXE 2
#define __ESKEL_SUMM_DYN 3
long sec_offset[4] = {-1L, -1L, -1L, -1L};

struct htree_s { __eskel_comp_t type; int nchr;    char *name; };
struct htree_s *htree;
int nproc, nnodes, __eskel_nmaps, __eskel_nleaves, *__eskel_maps;
long sched_count;
char **hnames;
double *latency, *durations;
time_t __eskel_exec_time[2];

int __eskel_read_env(void) {
    int i, j, k;

    /* Read the offset information if not already done. */
    if (sec_offset[__ESKEL_SUMM_ENV] == -1L)
        fread(sec_offset, sizeof(long)*4,
              1, __eskel_summary_file);

    /* Go to section. */
    fseek(__eskel_summary_file,
          sec_offset[__ESKEL_SUMM_ENV], SEEK_SET);

    /* Read number of nodes and their hostnames. */
    fread(&nproc, sizeof(int), 1, __eskel_summary_file);
    printf("nproc = %d\n", nproc);
    hnames = (char **) malloc(sizeof(char *)*nproc);
    for (i = 0; i < nproc; i++) {
        fread(&k, sizeof(int), 1, __eskel_summary_file);
        hnames[i] = (char *) malloc(sizeof(char)*(k + 1));
        for (j = 0; j < k; j++) {
            fread(&hnames[i][j], sizeof(char),
                  1, __eskel_summary_file);
        }
        hnames[i][j] = '\0';
        printf("%d %s\n", i, hnames[i]);
    }

    /* Read the latency. */
    latency = (double *) malloc(sizeof(double)*nproc*nproc);
    for (i = 0; i < nproc; i++) {
        for (j = 0; j < nproc; j++) {
            fread(__ESKEL_2DMBER_PTR(latency, i, j, nproc),
                  sizeof(double), 1, __eskel_summary_file);
            printf("%f ", __ESKEL_2DMBER(latency, i, j, nproc));
        }
        printf("\n");
    }
    return 0;
}

int __eskel_read_exe(void) {
    int i, j;

    /* Read the offset information if not already done. */
    if (sec_offset[__ESKEL_SUMM_EXE] == -1L)
        fread(sec_offset, sizeof(long)*4,
              1, __eskel_summary_file);

    /* Go to section. */
    fseek(__eskel_summary_file,
          sec_offset[__ESKEL_SUMM_EXE], SEEK_SET);

    /* Read the execution times. */
    fread(&__eskel_exec_time, sizeof(time_t),
          2, __eskel_summary_file);
    printf("Start: %s", ctime(&__eskel_exec_time[0]));
    printf("  End: %s", ctime(&__eskel_exec_time[1]));

    /* Read possible mappings. */
    fread(&__eskel_nmaps, sizeof(int), 1, __eskel_summary_file);
    fread(&__eskel_nleaves, sizeof(int), 1, __eskel_summary_file);
    printf("%d %d\n", __eskel_nmaps, __eskel_nleaves);
    __eskel_maps = (int *) malloc(sizeof(int)*__eskel_nmaps*__eskel_nleaves);
    durations = (double *) malloc(sizeof(double)*__eskel_nleaves);
    for (i = 0; i < __eskel_nmaps; i++) {
        for (j = 0; j < __eskel_nleaves; j++) {
            fread(__ESKEL_2DMBER_PTR(__eskel_maps,
                                     i, j, __eskel_nleaves),
                  sizeof(int), 1, __eskel_summary_file);
            printf("%d ", __ESKEL_2DMBER(__eskel_maps,
                                         i, j, __eskel_nleaves));
        }
        printf("\n");
    }

    /* Read task durations. */
    fread(durations, sizeof(double),
          __eskel_nleaves, __eskel_summary_file);
    for (i = 0; i < __eskel_nleaves; i++) {
        printf("%f ", durations[i]);
    }
    return 0;
}

/* Read the hierarchy tree. */
void __eskel_read_ske(void) {
    int i, j;
    
    /* Read the offset information if not already done. */
    if (sec_offset[__ESKEL_SUMM_SKE] == -1L)
        fread(sec_offset, sizeof(long)*4,
              1, __eskel_summary_file);

    /* Go to section. */
    fseek(__eskel_summary_file,
          sec_offset[__ESKEL_SUMM_SKE], SEEK_SET);

    /* Read the number of nodes in the hierarchy tree. */
    fread(&nnodes, sizeof(int), 1, __eskel_summary_file);

    htree = (struct htree_s *) malloc(sizeof(struct htree_s)*nnodes);
    for (i = 0; i < nnodes; i++) {
        /* Read the node type. */
        fread(&htree[i].type, sizeof(__eskel_comp_t),
              1, __eskel_summary_file);
        switch(htree[i].type) {
        case TASK:
            fread(&j, sizeof(__eskel_comp_t),
                  1, __eskel_summary_file);
            htree[i].name = (char *) malloc(sizeof(char)*(j+1));
            fread(htree[i].name, sizeof(char),
                  j, __eskel_summary_file);
            htree[i].name[j] = '\0';
            printf("task(%s);\n", htree[i].name);
            break;
        case DEAL:
            fread(&htree[i].nchr, sizeof(int),
                  1, __eskel_summary_file);
            htree[i].name = NULL;
            printf("deal(%d);\n", htree[i].nchr);
            break;
        case PIPE:
            fread(&htree[i].nchr, sizeof(int),
                  1, __eskel_summary_file);
            htree[i].name = NULL;
            printf("pipe(%d);\n", htree[i].nchr);
            break;
        default: ;
        }
    }
}

int __eskel_read_dyn(void) {
    __eskel_rmon_t *rmon;
    int map, i, j;

    /* Read the offset information if not already done. */
    if (sec_offset[__ESKEL_SUMM_DYN] == -1L)
        fread(sec_offset, sizeof(long)*4,
              1, __eskel_summary_file);

    /* Go to section. */
    fseek(__eskel_summary_file,
          sec_offset[__ESKEL_SUMM_DYN], SEEK_SET);

    /* Read the number of scheduling cycles. */
    fread(&sched_count, sizeof(long), 1, __eskel_summary_file);
    printf("Exec count: %ld\n", sched_count);
    rmon = (__eskel_rmon_t *) malloc(sizeof(__eskel_rmon_t)*nproc);

    for (i = 0; i < sched_count; i++) {
        /* Read what mapping. */
        fread(&map, sizeof(int), 1, __eskel_summary_file);

        /* Read resource information. */
        fread(rmon, sizeof(__eskel_rmon_t),
              nproc, __eskel_summary_file);
        
        printf("%d:\n", map);
        j = 0;
        for (j = 0; j < nproc - 1; j++) {
            printf("\t%f %f %f %f %f %f %f %d %d\n",
                   rmon[j].cpufreq, rmon[j].load[0],
                   rmon[j].load[1], rmon[j].load[2],
                   rmon[j].total, rmon[j].contrib,
                   rmon[j].theor, rmon[j].nprocs,
                   rmon[j].rprocs);
        }
    }
    free(rmon);
    return 0;
}

int main(void) {
    int i;
    if (!(__eskel_summary_file = fopen("eskel.summary", "rb"))) {
        perror("Cannot open file");
        exit(1);
    }

    __eskel_read_env();
    __eskel_read_exe();
    __eskel_read_ske();
    __eskel_read_dyn();

    fclose(__eskel_summary_file);
    free(latency);
    for (i = 0; i < nproc; i++)
        free(hnames[i]);
    free(hnames);
    free(__eskel_maps);
    free(durations);
    for (i = 0; i < nnodes; i++)
        if (htree[i].name) free(htree[i].name);
    free(htree);
    return 0;
}
